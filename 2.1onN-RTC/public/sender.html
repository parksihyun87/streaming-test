<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ğŸ“¡ ì†¡ì‹ ì í™”ë©´</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f4f7f6;
      color: #333;
    }
    h1 {
      color: #2c3e50;
      text-align: center;
      margin-bottom: 25px;
    }
    .section-container {
      background-color: #ffffff;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
    }
    .section-container h3 {
      color: #34495e;
      border-bottom: 2px solid #ecf0f1;
      padding-bottom: 10px;
      margin-top: 0;
      margin-bottom: 20px;
    }
    #roomSelection, #streamOptions, #nicknameSetting { /* Add #nicknameSetting */
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
      align-items: center;
    }
    #roomSelection input[type="text"], #nicknameSetting input[type="text"] { /* Apply to nickname input too */
      flex: 1;
      padding: 10px 15px;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 16px;
      min-width: 150px;
    }
    #roomSelection button, #streamOptions button, #nicknameSetting button { /* Apply to nickname button too */
      padding: 10px 20px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }
    #roomSelection button:hover, #streamOptions button:hover, #nicknameSetting button:hover { /* Apply to nickname button too */
      background-color: #0056b3;
    }
    #streamOptions button.active {
      background-color: #28a745;
    }
    #testCanvas {
      width: 100%;
      max-width: 640px;
      height: auto;
      aspect-ratio: 4/3; /* ìº”ë²„ìŠ¤ ë¹„ìœ¨ ìœ ì§€ */
      border: 2px solid #34495e;
      border-radius: 8px;
      margin: 0 auto 20px; /* ì¤‘ì•™ ì •ë ¬ ë° ì•„ë˜ ì—¬ë°± */
      display: block; /* ë¸”ë¡ ìš”ì†Œë¡œ ë³€ê²½í•˜ì—¬ margin auto ì‘ë™ */
      background-color: #000;
    }
    #viewerList {
      background-color: #e9ecef;
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
    }
    #viewerList ul {
      list-style: none;
      padding: 0;
      max-height: 120px;
      overflow-y: auto;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      background-color: #f8f9fa;
      padding: 10px;
    }
    #viewerList li {
      padding: 5px 0;
      border-bottom: 1px dashed #ced4da;
      font-size: 14px;
      color: #495057;
    }
    #viewerList li:last-child {
      border-bottom: none;
    }
    .viewer-item.fan { /* Style for fan in viewer list (sender side) */
        font-weight: bold;
        color: #9333ea;
    }
    #chatLog {
      height: 200px;
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 10px;
      background-color: white;
      border-radius: 8px;
      margin-bottom: 10px;
      font-size: 14px;
      line-height: 1.5;
    }
    .chat-message strong { /* Style for chat sender name */
        color: #007bff;
    }
    .chat-message.fan strong { /* Style for fan chat sender name */
        color: #9333ea;
    }
    .system-message {
      color: #6c757d;
      font-style: italic;
      text-align: center;
      margin: 10px 0;
      font-size: 14px;
      padding: 5px;
      border-radius: 5px;
      background: #e2e6ea;
    }
    .effect-message {
      background: linear-gradient(90deg, #ffedd5, #fef3c7);
      color: #8a6d3b;
      padding: 12px 18px;
      border-radius: 10px;
      margin: 8px 0;
      font-weight: bold;
      border: 2px solid #fce891;
      box-shadow: 0 4px 15px rgba(255, 215, 0, 0.5);
      animation: sparkle 1s ease-in-out;
      text-align: center;
    }
    @keyframes sparkle {
      0% { transform: scale(0.8); opacity: 0; }
      50% { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    #chatInputContainer {
      display: flex;
      gap: 10px;
    }
    #chatInput {
      flex: 1;
      padding: 10px;
      border: 1px solid #ced4da;
      border-radius: 5px;
      font-size: 16px;
    }
    #sendBtn {
      padding: 10px 20px;
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }
    #sendBtn:hover {
      background-color: #218838;
    }
    #status {
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      font-weight: bold;
      text-align: center;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    .status-connected {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .status-disconnected {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    .status-warning {
      background-color: #fff3cd;
      color: #856404;
      border: 1px solid #ffeeba;
    }
    #hiddenVideo {
      display: none;
    }
  </style>
</head>
<body>
  <h1>ğŸ“¡ ì†¡ì‹ ì í™”ë©´</h1>
  
  <div class="section-container">
    <h3>ğŸšª ë°© ì„¤ì •</h3>
    <div id="roomSelection">
      <label for="roomIdInput">ë°© ID:</label>
      <input type="text" id="roomIdInput" placeholder="ë°© IDë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: myRoom123)" value="defaultRoom" />
      <button id="setRoomBtn">ë°© ì„¤ì •</button>
      <div id="currentRoomDisplay">í˜„ì¬ ë°©: <span id="currentRoomId">ì„¤ì • ì•ˆë¨</span></div>
    </div>
  </div>

  <div class="section-container">
    <h3>ğŸ‘¤ ë‹‰ë„¤ì„ ì„¤ì •</h3>
    <div id="nicknameSetting">
      <label for="senderNicknameInput">ë‚´ ë‹‰ë„¤ì„:</label>
      <input type="text" id="senderNicknameInput" placeholder="ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”" value="ì†¡ì‹ ì" />
      <button id="changeSenderNicknameBtn">ë³€ê²½</button>
    </div>
  </div>

  <div class="section-container">
    <h3>ğŸ¬ ìŠ¤íŠ¸ë¦¼ ì˜µì…˜</h3>
    <div id="streamOptions">
      <button id="cameraBtn">ğŸ“¹ ì¹´ë©”ë¼ + ì˜¤ë””ì˜¤</button>
      <button id="audioOnlyBtn">ğŸ¤ ì˜¤ë””ì˜¤ë§Œ</button>
      <button id="canvasBtn">ğŸ¨ ê°€ìƒ ë¹„ë””ì˜¤</button>
      <button id="screenShareBtn">ğŸ–¥ï¸ í™”ë©´ ê³µìœ </button>
      <button id="dataOnlyBtn">ğŸ“Š ë°ì´í„°ë§Œ</button>
    </div>
  </div>
  
  <canvas id="testCanvas" width="640" height="480"></canvas>
  <video id="hiddenVideo" autoplay muted playsinline></video>

  <div class="section-container">
    <h3>ğŸ‘¥ ì ‘ì† ì¤‘ì¸ ìˆ˜ì‹ ì (<span id="viewerCount">0</span>ëª…)</h3>
    <div id="viewerList">
      <ul id="activeViewers">
        </ul>
    </div>
  </div>
  
  <div class="section-container">
    <h3>ğŸ’¬ ì±„íŒ…</h3>
    <div id="chatLog"></div>
    <div id="chatInputContainer">
      <input type="text" id="chatInput" placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..." autocomplete="off" />
      <button id="sendBtn" disabled>ì „ì†¡</button>
    </div>
  </div>
  
  <div id="status" class="status-disconnected">ì‹œê·¸ë„ë§ ì„œë²„ì— ì—°ê²° ì¤‘...</div>

  <script>
    const senderId = "sender"; // ì†¡ì‹ ì ê³ ìœ  ID
    const ws = new WebSocket("ws://192.168.0.238:8080");
    // const ws = new WebSocket("ws://localhost:8080");
    const testCanvas = document.getElementById("testCanvas");
    const ctx = testCanvas.getContext("2d");
    const hiddenVideo = document.getElementById("hiddenVideo");
    const chatInput = document.getElementById("chatInput");
    const chatLog = document.getElementById("chatLog");
    const sendBtn = document.getElementById("sendBtn");
    const status = document.getElementById("status");
    const roomIdInput = document.getElementById("roomIdInput");
    const setRoomBtn = document.getElementById("setRoomBtn");
    const currentRoomIdDisplay = document.getElementById("currentRoomId");
    const activeViewersList = document.getElementById("activeViewers");
    const viewerCountDisplay = document.getElementById("viewerCount");
    const senderNicknameInput = document.getElementById("senderNicknameInput"); // New sender nickname input
    const changeSenderNicknameBtn = document.getElementById("changeSenderNicknameBtn"); // New sender nickname change button

    let localStream = null;
    let animationId = null;
    const peerConnections = new Map(); // key: viewerId, value: RTCPeerConnection
    const iceCandidateQueues = new Map(); // key: viewerId, value: Array<RTCIceCandidate>
    let isWsConnected = false; // WebSocket ì—°ê²° ìƒíƒœ
    let isStreamActive = false; // ìŠ¤íŠ¸ë¦¼ í™œì„±í™” ìƒíƒœ (ë¯¸ë””ì–´ íŠ¸ë™ ì „ì†¡ ì¤€ë¹„ ì™„ë£Œ)
    let currentMode = null; // í˜„ì¬ ìŠ¤íŠ¸ë¦¬ë° ëª¨ë“œ (camera, audio, canvas, screen, data)
    let selectedRoomId = "defaultRoom"; // ì‚¬ìš©ìê°€ ì„ íƒí•œ ë°© ID
    let currentSenderNickname = localStorage.getItem('senderNickname') || "ì†¡ì‹ ì"; // Load sender nickname

    // ì´ˆê¸° ë°© ID ë° ë‹‰ë„¤ì„ í‘œì‹œ
    currentRoomIdDisplay.textContent = selectedRoomId;
    roomIdInput.value = selectedRoomId;
    senderNicknameInput.value = currentSenderNickname;

    // WebSocket ì—°ê²° ì²˜ë¦¬
    ws.onopen = () => {
      console.log("ğŸ”— WebSocket ì—°ê²°ë¨");
      isWsConnected = true;
      updateStatus("WebSocket ì—°ê²°ë¨. ë°©ì„ ì„¤ì •í•˜ê³  ìŠ¤íŠ¸ë¦¼ ì˜µì…˜ì„ ì„ íƒí•˜ì„¸ìš”.", "status-warning");
      // ë°© ì„¤ì • ë²„íŠ¼ í™œì„±í™”
      setRoomBtn.disabled = false;
      // Initial sender role message with nickname
      // This will be sent after setRoomBtn is clicked
    };

    ws.onclose = () => {
      console.log("âŒ WebSocket ì—°ê²° ì¢…ë£Œ");
      isWsConnected = false;
      updateStatus("ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤.", "status-disconnected");
      sendBtn.disabled = true;
      // ëª¨ë“  PeerConnection ì¢…ë£Œ
      peerConnections.forEach(pc => pc.close());
      peerConnections.clear();
      activeViewersList.innerHTML = '';
      viewerCountDisplay.textContent = '0';
    };

    ws.onerror = (error) => {
      console.error("ğŸš¨ WebSocket ì˜¤ë¥˜:", error);
      updateStatus("ì—°ê²° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", "status-disconnected");
    };

    ws.onmessage = async (event) => {
      try {
        const data = JSON.parse(event.data);
        console.log("ğŸ“¨ ë©”ì‹œì§€ ìˆ˜ì‹ :", data);

        switch (data.type) {
          case "viewer-joined":
            // data now contains nickname and isFan
            await handleViewerJoined(data.viewerId, data.nickname, data.isFan);
            break;
          case "answer":
            await handleAnswer(data);
            break;
          case "candidate":
            await handleCandidate(data);
            break;
          case "viewer-left":
            handleViewerLeft(data.viewerId);
            break;
          case "chat":
            // Pass isFan status to appendChatMessage
            appendChatMessage(data.from, data.message, data.isFan);
            break;
          case "like":
            appendSystemMessage(`â¤ï¸ ${data.from}${data.isFan ? '(íŒ¬)' : ''}ë‹˜ì´ ì¢‹ì•„ìš”ë¥¼ ëˆŒë €ìŠµë‹ˆë‹¤!`); // Show fan status
            break;
          case "star-balloon":
            appendSystemMessage(`â­ ${data.from}${data.isFan ? '(íŒ¬)' : ''}ë‹˜ì´ ë³„í’ì„  ${data.count}ê°œë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤!`); // Show fan status
            break;
          case "nickname-change":
            const displayOldNickname = data.isFan ? `[íŒ¬]${data.oldNickname}` : data.oldNickname;
            const displayNewNickname = data.isFan ? `[íŒ¬]${data.newNickname}` : data.newNickname;
            appendSystemMessage(`ğŸ“ ${displayOldNickname}ë‹˜ì´ ë‹‰ë„¤ì„ì„ "${displayNewNickname}"ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤.`);
            break;
          case "room-members":
            // data.members now includes nickname and isFan status
            updateViewerList(data.members, data.senderNickname); // Pass senderNickname
            break;
          case "fan-status-update": // New: Handle fan status updates from server
            appendSystemMessage(`ğŸ’œ ${data.nickname}ë‹˜ì´ ${data.isFan ? 'íŒ¬ì´ ë˜ì—ˆìŠµë‹ˆë‹¤!' : 'íŒ¬ ê°€ì…ì„ í•´ì œí–ˆìŠµë‹ˆë‹¤.'}`);
            // Re-broadcast room members to update list with fan status
            // This is already triggered by the server, so no need to explicitly call here.
            break;
          case "sender-nickname-change": // New: Handle sender nickname change (for sender itself to confirm)
            // This message is primarily for viewers, sender's UI is updated locally
            // But if sender receives it, it confirms the server processed it.
            console.log(`ì†¡ì‹ ì ë‹‰ë„¤ì„ì´ "${data.newNickname}"ìœ¼ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.`);
            break;
          default:
            console.warn("âš ï¸ ì•Œ ìˆ˜ ì—†ëŠ” ë©”ì‹œì§€ íƒ€ì…:", data.type);
        }
      } catch (error) {
        console.error("âŒ ë©”ì‹œì§€ ì²˜ë¦¬ ì˜¤ë¥˜:", error);
      }
    };

    // ë°© ì„¤ì • ë° ì†¡ì‹ ì ì—­í•  ì „ì†¡
    setRoomBtn.addEventListener("click", () => {
      const newRoomId = roomIdInput.value.trim();
      if (newRoomId && isWsConnected) {
        selectedRoomId = newRoomId;
        currentRoomIdDisplay.textContent = selectedRoomId;
        // Send sender role message with current nickname
        ws.send(JSON.stringify({ role: "sender", roomId: selectedRoomId, nickname: currentSenderNickname }));
        updateStatus(`ë°© "${selectedRoomId}"ìœ¼ë¡œ ì„¤ì •ë¨. ìŠ¤íŠ¸ë¦¼ ì˜µì…˜ì„ ì„ íƒí•˜ì„¸ìš”.`, "status-warning");
        console.log(`âœ… ë°© ID ì„¤ì •: ${selectedRoomId}`);
        sendBtn.disabled = false; // ë°©ì„ ì„¤ì •í–ˆìœ¼ë¯€ë¡œ ì±„íŒ… ì „ì†¡ ë²„íŠ¼ í™œì„±í™”
      } else {
        alert("ìœ íš¨í•œ ë°© IDë¥¼ ì…ë ¥í•˜ê³  WebSocketì´ ì—°ê²°ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.");
      }
    });

    // ë£¸ ID ì…ë ¥ì°½ì—ì„œ Enter í‚¤
    roomIdInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        setRoomBtn.click();
      }
    });

    // New: Change sender nickname
    changeSenderNicknameBtn.addEventListener("click", () => {
      const newNickname = senderNicknameInput.value.trim();
      if (newNickname && newNickname !== currentSenderNickname) {
        const oldNickname = currentSenderNickname;
        currentSenderNickname = newNickname;
        localStorage.setItem('senderNickname', currentSenderNickname); // Persist sender nickname
        // Send nickname change to server
        if (isWsConnected && selectedRoomId) {
            ws.send(JSON.stringify({
                type: "sender-nickname-change",
                newNickname: newNickname,
                roomId: selectedRoomId
            }));
            appendSystemMessage(`ğŸ“ ë‚´ ë‹‰ë„¤ì„ì„ "${newNickname}"ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤.`);
        } else {
            alert("WebSocketì´ ì—°ê²°ë˜ì–´ ìˆê³  ë°©ì´ ì„¤ì •ë˜ì–´ ìˆì–´ì•¼ ë‹‰ë„¤ì„ì„ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
        }
      } else if (!newNickname) {
        alert("ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
      }
    });

    senderNicknameInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        changeSenderNicknameBtn.click();
      }
    });

    // WebRTC connection setup functions (mostly existing, with minor modifications)
    async function createPeerConnection(viewerId) {
        // ... (existing code for RTCPeerConnection setup)
        const pc = new RTCPeerConnection({
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" },
            ],
        });

        pc.onicecandidate = (event) => {
            if (event.candidate) {
                console.log("ICE candidate ì „ì†¡:", event.candidate);
                ws.send(
                    JSON.stringify({
                        type: "candidate",
                        candidate: event.candidate,
                        to: viewerId,
                        from: senderId,
                        roomId: selectedRoomId,
                    })
                );
            }
        };

        let dataChannel = pc.createDataChannel("chat");
        dataChannel.onopen = () => {
            console.log("Data Channel opened with", viewerId);
            // Optionally send initial data or welcome message
        };
        dataChannel.onmessage = (e) => {
            const msg = JSON.parse(e.data);
            console.log('Data Channel Message from viewer:', msg);
            if (msg.type === "chat") {
              appendChatMessage(msg.from, msg.message, msg.isFan);
            } else if (msg.type === "like") {
              appendSystemMessage(`â¤ï¸ ${msg.from}${msg.isFan ? '(íŒ¬)' : ''}ë‹˜ì´ ì¢‹ì•„ìš”ë¥¼ ëˆŒë €ìŠµë‹ˆë‹¤!`);
            } else if (msg.type === "star-balloon") {
              appendSystemMessage(`â­ ${msg.from}${msg.isFan ? '(íŒ¬)' : ''}ë‹˜ì´ ë³„í’ì„  ${msg.count}ê°œë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤!`);
            }
        };
        dataChannel.onclose = () => console.log("Data Channel closed with", viewerId);
        dataChannel.onerror = (error) => console.error("Data Channel error with", viewerId, error);

        return pc;
    }

    async function handleViewerJoined(viewerId, nickname, isFan) { // Add nickname and isFan
      console.log(`[${viewerId}] ìˆ˜ì‹ ì ì ‘ì†. PeerConnection ìƒì„± ì¤‘...`);
      // ê¸°ì¡´ ì—°ê²°ì´ ìˆë‹¤ë©´ ì œê±°í•˜ê³  ìƒˆë¡œ ë§Œë“­ë‹ˆë‹¤. (ì¬ì ‘ì† ì²˜ë¦¬)
      if (peerConnections.has(viewerId)) {
        peerConnections.get(viewerId).close();
        peerConnections.delete(viewerId);
        iceCandidateQueues.delete(viewerId);
      }

      const pc = await createPeerConnection(viewerId);
      peerConnections.set(viewerId, pc);
      iceCandidateQueues.set(viewerId, []); // ê° ìˆ˜ì‹ ìë³„ë¡œ ICE í ê´€ë¦¬

      // ê¸°ì¡´ ìŠ¤íŠ¸ë¦¼ì´ ìˆë‹¤ë©´ íŠ¸ë™ ì¶”ê°€
      if (localStream) {
        localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));
        console.log(`[${viewerId}] ê¸°ì¡´ ìŠ¤íŠ¸ë¦¼ íŠ¸ë™ ì¶”ê°€ë¨.`);
      }

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      ws.send(
        JSON.stringify({
          type: "offer",
          offer: pc.localDescription,
          to: viewerId,
          from: senderId,
          roomId: selectedRoomId,
        })
      );
      console.log(`[${viewerId}] Offer ì „ì†¡ ì™„ë£Œ.`);
      updateStatus("ğŸŸ¢ ìŠ¤íŠ¸ë¦¬ë° ì¤€ë¹„ ì™„ë£Œ. ìˆ˜ì‹ ì ì‘ë‹µ ëŒ€ê¸° ì¤‘...", "status-connected");
      // updateViewerList(); // ìƒˆë¡œìš´ ìˆ˜ì‹ ì ì ‘ì† ì‹œ ëª©ë¡ ì—…ë°ì´íŠ¸
    }

    async function handleAnswer(data) {
      const pc = peerConnections.get(data.from);
      if (!pc) {
        console.error("Answerë¥¼ ë³´ë‚¸ ìˆ˜ì‹ ìì— ëŒ€í•œ PeerConnectionì´ ì—†ìŠµë‹ˆë‹¤:", data.from);
        return;
      }
      const remoteDesc = new RTCSessionDescription(data.answer);
      await pc.setRemoteDescription(remoteDesc);
      console.log(`[${data.from}] Answer ìˆ˜ì‹  ë° RemoteDescription ì„¤ì • ì™„ë£Œ.`);
      // Process queued ICE candidates for this viewer
      const queue = iceCandidateQueues.get(data.from);
      if (queue) {
        queue.forEach(candidate => pc.addIceCandidate(candidate));
        iceCandidateQueues.set(data.from, []); // Clear the queue
      }
    }

    async function handleCandidate(data) {
      const pc = peerConnections.get(data.from);
      if (pc) {
        const candidate = new RTCIceCandidate(data.candidate);
        if (pc.remoteDescription && pc.remoteDescription.type) {
          try {
            await pc.addIceCandidate(candidate);
            console.log(`[${data.from}] ICE candidate ì¶”ê°€ ì™„ë£Œ.`);
          } catch (e) {
            console.error(`[${data.from}] ICE candidate ì¶”ê°€ ì˜¤ë¥˜:`, e);
          }
        } else {
          // Offer/Answerê°€ ì•„ì§ ì˜¤ì§€ ì•Šì•˜ë‹¤ë©´ íì— ì €ì¥
          iceCandidateQueues.get(data.from).push(candidate);
          console.log(`[${data.from}] ICE candidate íì— ì¶”ê°€ë¨.`);
        }
      } else {
        console.warn(`[${data.from}] PeerConnectionì´ ì—†ì–´ ICE candidate ë¬´ì‹œ.`);
        // PeerConnectionì´ ì—†ìœ¼ë©´ íì— ì¶”ê°€ (handleViewerJoinedì—ì„œ PC ìƒì„± í›„ ì²˜ë¦¬)
        if (!iceCandidateQueues.has(data.from)) {
          iceCandidateQueues.set(data.from, []);
        }
        iceCandidateQueues.get(data.from).push(new RTCIceCandidate(data.candidate));
      }
    }

    function handleViewerLeft(viewerId) {
      if (peerConnections.has(viewerId)) {
        peerConnections.get(viewerId).close();
        peerConnections.delete(viewerId);
        iceCandidateQueues.delete(viewerId);
        console.log(`[${viewerId}] ìˆ˜ì‹ ì ì—°ê²° í•´ì œ ë° PeerConnection ì œê±°.`);
      }
      // updateViewerList(); // ìˆ˜ì‹ ì ë‚˜ê°ˆ ë•Œ ëª©ë¡ ì—…ë°ì´íŠ¸
    }

    // ìŠ¤íŠ¸ë¦¼ ê´€ë ¨ í•¨ìˆ˜ë“¤ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
    // ... (initCamera, initAudioOnly, initCanvasStream, initScreenShare, initDataOnly, 
    // stopCurrentStream, drawVideoToCanvas, drawAudioVisualization, drawCanvasAnimation, 
    // drawScreenShareInfo, drawDataOnlyInfo, updateStreamStatus, updateButtonStates í•¨ìˆ˜ë“¤)

    // ì›ë³¸ ì¹´ë©”ë¼ + ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼
    async function initCamera() {
      if (!selectedRoomId) {
        alert("ë¨¼ì € ë°© IDë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”!");
        return;
      }
      try {
        stopCurrentStream();
        localStream = await navigator.mediaDevices.getUserMedia({ 
          video: true, 
          audio: true 
        });
        
        currentMode = "camera";
        hiddenVideo.srcObject = localStream;
        await new Promise((resolve) => {
          hiddenVideo.onloadedmetadata = () => {
            resolve();
          };
        });
        await hiddenVideo.play();
        setTimeout(() => {
          drawVideoToCanvas();
          updateStreamStatus(true);
        }, 100);
        updateStatus("ğŸ“¹ ì¹´ë©”ë¼ + ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ì¤€ë¹„ ì™„ë£Œ", "status-connected");
        console.log("ğŸ“¹ ì¹´ë©”ë¼ + ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ íšë“ ì™„ë£Œ");
        // ëª¨ë“  ê¸°ì¡´ PeerConnectionì— íŠ¸ë™ ì¶”ê°€
        updateAllPeerConnectionsWithStream();
      } catch (error) {
        console.error("âŒ ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ ì˜¤ë¥˜:", error);
        updateStatus("ì¹´ë©”ë¼/ë§ˆì´í¬ ì ‘ê·¼ ì‹¤íŒ¨", "status-disconnected");
        updateStreamStatus(false);
      }
    }

    // ë¹„ë””ì˜¤ë¥¼ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸° (ìˆ˜ì •ëœ ë²„ì „)
    function drawVideoToCanvas() {
      if (currentMode !== "camera") {
        return;
      }
      function draw() {
        if (currentMode === "camera" && localStream && hiddenVideo.srcObject) {
          if (hiddenVideo.readyState >= 2 && hiddenVideo.videoWidth > 0) {
            try {
              ctx.drawImage(hiddenVideo, 0, 0, testCanvas.width, testCanvas.height);
            } catch (error) {
              console.warn("ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸° ì˜¤ë¥˜ (drawVideoToCanvas):", error);
            }
          } else {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, testCanvas.width, testCanvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ì¹´ë©”ë¼ ë¡œë”© ì¤‘...', testCanvas.width/2, testCanvas.height/2);
          }
          animationId = requestAnimationFrame(draw);
        }
      }
      draw();
    }

    // ì˜¤ë””ì˜¤ë§Œ ìŠ¤íŠ¸ë¦¼
    async function initAudioOnly() {
      if (!selectedRoomId) {
        alert("ë¨¼ì € ë°© IDë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”!");
        return;
      }
      try {
        stopCurrentStream();
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        currentMode = "audio";
        updateStatus("ğŸ¤ ì˜¤ë””ì˜¤ë§Œ ìŠ¤íŠ¸ë¦¼ ì¤€ë¹„ ì™„ë£Œ", "status-connected");
        drawAudioVisualization();
        console.log("ğŸ¤ ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ íšë“ ì™„ë£Œ");
        updateStreamStatus(true);
        updateAllPeerConnectionsWithStream();
      } catch (error) {
        console.error("âŒ ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ì˜¤ë¥˜:", error);
        updateStatus("ë§ˆì´í¬ ì ‘ê·¼ ì‹¤íŒ¨", "status-disconnected");
        updateStreamStatus(false);
      }
    }

    // ê°€ìƒ ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¼
    async function initCanvasStream() {
      if (!selectedRoomId) {
        alert("ë¨¼ì € ë°© IDë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”!");
        return;
      }
      try {
        stopCurrentStream();
        drawCanvasAnimation();
        localStream = testCanvas.captureStream(30); // 30 FPS
        currentMode = "canvas";
        updateStatus("ğŸ¨ ê°€ìƒ ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ì¤€ë¹„ ì™„ë£Œ", "status-connected");
        console.log("ğŸ¨ ìº”ë²„ìŠ¤ ìŠ¤íŠ¸ë¦¼ ìƒì„± ì™„ë£Œ");
        updateStreamStatus(true);
        updateAllPeerConnectionsWithStream();
      } catch (error) {
        console.error("âŒ ìº”ë²„ìŠ¤ ìŠ¤íŠ¸ë¦¼ ì˜¤ë¥˜:", error);
        updateStatus("ìº”ë²„ìŠ¤ ìŠ¤íŠ¸ë¦¼ ìƒì„± ì‹¤íŒ¨", "status-disconnected");
        updateStreamStatus(false);
      }
    }

    // í™”ë©´ ê³µìœ  ìŠ¤íŠ¸ë¦¼
    async function initScreenShare() {
      if (!selectedRoomId) {
        alert("ë¨¼ì € ë°© IDë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”!");
        return;
      }
      try {
        stopCurrentStream();
        localStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
        currentMode = "screen";
        updateStatus("ğŸ–¥ï¸ í™”ë©´ ê³µìœ  ìŠ¤íŠ¸ë¦¼ ì¤€ë¹„ ì™„ë£Œ", "status-connected");
        drawScreenShareInfo();
        console.log("ğŸ–¥ï¸ í™”ë©´ ê³µìœ  ìŠ¤íŠ¸ë¦¼ íšë“ ì™„ë£Œ");
        updateStreamStatus(true);
        updateAllPeerConnectionsWithStream();
        // í™”ë©´ ê³µìœ  ì¤‘ë‹¨ ì‹œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        localStream.getVideoTracks()[0].onended = () => {
          console.log("í™”ë©´ ê³µìœ ê°€ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.");
          initDataOnly(); // í™”ë©´ ê³µìœ  ì¤‘ë‹¨ ì‹œ ë°ì´í„° ì „ìš© ëª¨ë“œë¡œ ì „í™˜ (ë˜ëŠ” ë‹¤ë¥¸ ê¸°ë³¸ ëª¨ë“œë¡œ)
          updateStatus("í™”ë©´ ê³µìœ  ì¤‘ë‹¨ë¨. ë°ì´í„° ì „ìš© ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤.", "status-warning");
          updateButtonStates(document.getElementById('dataOnlyBtn'));
        };
      } catch (error) {
        console.error("âŒ í™”ë©´ ê³µìœ  ìŠ¤íŠ¸ë¦¼ ì˜¤ë¥˜:", error);
        updateStatus("í™”ë©´ ê³µìœ  ì ‘ê·¼ ì‹¤íŒ¨", "status-disconnected");
        updateStreamStatus(false);
      }
    }

    // ë°ì´í„°ë§Œ (WebRTC ì—°ê²° í…ŒìŠ¤íŠ¸)
    async function initDataOnly() {
      if (!selectedRoomId) {
        alert("ë¨¼ì € ë°© IDë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”!");
        return;
      }
      stopCurrentStream(); // ë¯¸ë””ì–´ ìŠ¤íŠ¸ë¦¼ ì¤‘ë‹¨
      localStream = null; // ìŠ¤íŠ¸ë¦¼ ì œê±°
      currentMode = "data";
      updateStatus("ğŸ“Š ë°ì´í„° ì±„ë„ ì „ìš© ëª¨ë“œ (WebRTC ì—°ê²° í…ŒìŠ¤íŠ¸)", "status-connected");
      drawDataOnlyInfo();
      console.log("ğŸ“Š ë°ì´í„° ì „ìš© ëª¨ë“œ í™œì„±í™”");
      updateStreamStatus(true);
      // ë°ì´í„° ì „ìš© ëª¨ë“œì—ì„œëŠ” ë¯¸ë””ì–´ íŠ¸ë™ì„ ì œê±°í•˜ê³  ìƒˆë¡œ ì—°ê²°ëœ PeerConnectionì— DataChannelë§Œ ì¶”ê°€
      // ê¸°ì¡´ PeerConnectionë“¤ì€ ë¯¸ë””ì–´ íŠ¸ë™ì´ ì—†ì–´ë„ ìœ ì§€ë  ìˆ˜ ìˆìŒ
      updateAllPeerConnectionsWithStream(); // Call this to ensure DataChannels are handled
    }

    // í˜„ì¬ ìŠ¤íŠ¸ë¦¼ ì •ì§€ ë° ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
    function stopCurrentStream() {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
        console.log("âŒ í˜„ì¬ ìŠ¤íŠ¸ë¦¼ ì •ì§€ë¨");
      }
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      hiddenVideo.srcObject = null;
      hiddenVideo.onloadedmetadata = null;
      hiddenVideo.onplay = null;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, testCanvas.width, testCanvas.height);
    }

    // ëª¨ë“  PeerConnectionì— í˜„ì¬ localStreamì˜ íŠ¸ë™ì„ ì¶”ê°€í•˜ê±°ë‚˜ ì œê±°
    async function updateAllPeerConnectionsWithStream() {
      // ê¸°ì¡´ íŠ¸ë™ ì œê±°
      peerConnections.forEach(pc => {
        pc.getSenders().forEach(sender => {
          if (sender.track) {
            pc.removeTrack(sender);
          }
        });
      });

      // ìƒˆ íŠ¸ë™ ì¶”ê°€
      if (localStream) {
        peerConnections.forEach(pc => {
          localStream.getTracks().forEach(track => {
            pc.addTrack(track, localStream);
          });
        });
        console.log("ìƒˆ ìŠ¤íŠ¸ë¦¼ íŠ¸ë™ì´ ëª¨ë“  PeerConnectionì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.");
      } else {
          console.log("ë¡œì»¬ ìŠ¤íŠ¸ë¦¼ì´ ì—†ì–´ ëª¨ë“  PeerConnectionì—ì„œ íŠ¸ë™ì„ ì œê±°í–ˆìŠµë‹ˆë‹¤.");
      }
       // Offers might need to be renegotiated after track changes
       peerConnections.forEach(async (pc, viewerId) => {
            try {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                ws.send(
                    JSON.stringify({
                        type: "offer",
                        offer: pc.localDescription,
                        to: viewerId,
                        from: senderId,
                        roomId: selectedRoomId,
                    })
                );
                console.log(`[${viewerId}] Offer (íŠ¸ë™ ë³€ê²½) ì „ì†¡ ì™„ë£Œ.`);
            } catch (error) {
                console.error(`[${viewerId}] Offer ìƒì„± ë˜ëŠ” ì „ì†¡ ì‹¤íŒ¨ (íŠ¸ë™ ë³€ê²½):`, error);
            }
        });
    }

// ìŠ¤íŠ¸ë¦¼ ìƒíƒœ ì—…ë°ì´íŠ¸ (UI)
function updateStreamStatus(active) {
    isStreamActive = active;
    const streamButtons = document.querySelectorAll("#streamOptions button");

    // 1. ëª¨ë“  ìŠ¤íŠ¸ë¦¼ ë²„íŠ¼ì—ì„œ 'active' í´ë˜ìŠ¤ë¥¼ í•œ ë²ˆì— ì œê±°í•˜ì—¬ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
    streamButtons.forEach(button => {
        button.classList.remove("active");
    });

    if (active) { // ìŠ¤íŠ¸ë¦¼ì´ í˜„ì¬ í™œì„±í™”ëœ ê²½ìš° (ì¹´ë©”ë¼, ì˜¤ë””ì˜¤, ìº”ë²„ìŠ¤, í™”ë©´ ê³µìœ  ë“±)
        if (currentMode === "data") {
            // ë°ì´í„° ì „ìš© ëª¨ë“œì¼ ê²½ìš° 'dataOnlyBtn'ë§Œ í™œì„±í™”
            const dataOnlyButton = document.getElementById("dataOnlyBtn");
            if (dataOnlyButton) { // âœ… ìš”ì†Œê°€ ì¡´ì¬í•˜ëŠ”ì§€ ë°©ì–´ì  í™•ì¸
                dataOnlyButton.classList.add("active");
            }
        } else {
            // ê·¸ ì™¸ ìŠ¤íŠ¸ë¦¼ (ì¹´ë©”ë¼, í™”ë©´ ê³µìœ  ë“±)ì€ í•´ë‹¹ 'currentMode'ì— ë§ëŠ” ë²„íŠ¼ì„ í™œì„±í™”
            const activeButton = document.getElementById(`${currentMode}Btn`);
            if (activeButton) { // âœ… ìš”ì†Œê°€ ì¡´ì¬í•˜ëŠ”ì§€ ë°©ì–´ì  í™•ì¸
                activeButton.classList.add("active");
            }
        }
        sendBtn.disabled = false; // ìŠ¤íŠ¸ë¦¼ì´ í™œì„±í™”ë˜ë©´ ì±„íŒ…ë„ ê°€ëŠ¥
    } else { // ìŠ¤íŠ¸ë¦¼ì´ ë¹„í™œì„±í™”ëœ ê²½ìš° (ì—°ê²° ëŠê¹€, ì¤‘ë‹¨ ë“±)
        // ëª¨ë“  ë²„íŠ¼ì—ì„œ active í´ë˜ìŠ¤ëŠ” ì´ë¯¸ ìœ„ì—ì„œ ì œê±°ë˜ì—ˆìœ¼ë¯€ë¡œ ì¶”ê°€ ì‘ì—… ë¶ˆí•„ìš”
        sendBtn.disabled = true; // ì±„íŒ… ê¸°ëŠ¥ ë¹„í™œì„±í™”
    }

    // ë””ë²„ê¹…ì„ ìœ„í•œ ê²½ê³  ë©”ì‹œì§€ (currentModeê°€ ì˜ˆìƒëŒ€ë¡œ ì„¤ì •ë˜ì§€ ì•Šì•˜ì„ ê²½ìš°)
    if (!currentMode) {
        console.warn("ê²½ê³ : currentModeê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. updateStreamStatus í•¨ìˆ˜ê°€ ì˜ˆìƒëŒ€ë¡œ ì‘ë™í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
    }
}

    // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸ (CSS active í´ë˜ìŠ¤)
    function updateButtonStates(activeButton) {
      const buttons = document.querySelectorAll("#streamOptions button");
      buttons.forEach(button => {
        button.classList.remove("active");
      });
      if (activeButton) {
        activeButton.classList.add("active");
      }
    }

    // ìº”ë²„ìŠ¤ ì• ë‹ˆë©”ì´ì…˜
    function drawCanvasAnimation() {
      const centerX = testCanvas.width / 2;
      const centerY = testCanvas.height / 2;
      const radius = Math.min(centerX, centerY) * 0.4;
      let angle = 0;

      function animate() {
        ctx.clearRect(0, 0, testCanvas.width, testCanvas.height);
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(0, 0, testCanvas.width, testCanvas.height);

        ctx.beginPath();
        ctx.arc(centerX + Math.cos(angle) * radius, centerY + Math.sin(angle) * radius, 30, 0, Math.PI * 2);
        ctx.fillStyle = '#3498db';
        ctx.fill();

        ctx.beginPath();
        ctx.arc(centerX + Math.cos(angle + Math.PI) * radius, centerY + Math.sin(angle + Math.PI) * radius, 30, 0, Math.PI * 2);
        ctx.fillStyle = '#e74c3c';
        ctx.fill();

        angle += 0.05;
        if (currentMode === "canvas") {
            animationId = requestAnimationFrame(animate);
        }
      }
      animate();
    }

    // ì˜¤ë””ì˜¤ ì‹œê°í™” (ì„ì‹œ)
    function drawAudioVisualization() {
      ctx.clearRect(0, 0, testCanvas.width, testCanvas.height);
      ctx.fillStyle = '#f0f0f0';
      ctx.fillRect(0, 0, testCanvas.width, testCanvas.height);
      ctx.fillStyle = '#2ecc71';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('ğŸ¤ ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ì¤‘...', testCanvas.width / 2, testCanvas.height / 2);
    }

    // í™”ë©´ ê³µìœ  ì •ë³´
    function drawScreenShareInfo() {
      ctx.clearRect(0, 0, testCanvas.width, testCanvas.height);
      ctx.fillStyle = '#f0f0f0';
      ctx.fillRect(0, 0, testCanvas.width, testCanvas.height);
      ctx.fillStyle = '#e67e22';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('ğŸ–¥ï¸ í™”ë©´ ê³µìœ  ì¤‘...', testCanvas.width / 2, testCanvas.height / 2);
    }

    // ë°ì´í„° ì „ìš© ì •ë³´
    function drawDataOnlyInfo() {
      ctx.clearRect(0, 0, testCanvas.width, testCanvas.height);
      ctx.fillStyle = '#f0f0f0';
      ctx.fillRect(0, 0, testCanvas.width, testCanvas.height);
      ctx.fillStyle = '#34495e';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('ğŸ“Š ë°ì´í„° ì „ìš© ëª¨ë“œ', testCanvas.width / 2, testCanvas.height / 2);
    }

    // UI ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    function updateStatus(message, className) {
      status.textContent = message;
      status.className = "status " + className;
    }

    function appendChatMessage(from, message, isFan = false) { // Add isFan parameter
      const chatMessageElem = document.createElement("div");
      chatMessageElem.classList.add("chat-message");
      let senderText = from;
      if (isFan) {
          senderText = `[íŒ¬]${from}`; // Prepend [íŒ¬] if fan
          chatMessageElem.classList.add("fan"); // Add class for fan styling
      }
      chatMessageElem.innerHTML = `<strong>${senderText}:</strong> ${message}`;
      chatLog.appendChild(chatMessageElem);
      chatLog.scrollTop = chatLog.scrollHeight; // ìŠ¤í¬ë¡¤ì„ í•­ìƒ ìµœí•˜ë‹¨ìœ¼ë¡œ
    }

    function appendSystemMessage(message) {
      const systemMessageElem = document.createElement("div");
      systemMessageElem.classList.add("system-message");
      systemMessageElem.textContent = message;
      chatLog.appendChild(systemMessageElem);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function updateViewerList(members, senderNicknameFromServer) { // Add senderNicknameFromServer
      activeViewersList.innerHTML = '';
      viewerCountDisplay.textContent = members.length;

      // Update sender's nickname display if it came from server
      if (senderNicknameFromServer && senderNicknameFromServer !== currentSenderNickname) {
        currentSenderNickname = senderNicknameFromServer;
        senderNicknameInput.value = currentSenderNickname;
        localStorage.setItem('senderNickname', currentSenderNickname);
        appendSystemMessage(`ğŸ“ ì†¡ì‹ ìì˜ ë‹‰ë„¤ì„ì´ "${currentSenderNickname}"ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      }

      // Add sender to the list (always first)
      const senderLi = document.createElement("li");
      senderLi.textContent = `ğŸ¥ ${currentSenderNickname} (ë‚˜, ì†¡ì‹ ì)`;
      activeViewersList.appendChild(senderLi);

      members.forEach(member => {
          const li = document.createElement("li");
          let displayName = member.nickname;
          if (member.isFan) {
              displayName = `[íŒ¬]${member.nickname}`;
              li.classList.add("fan"); // Add class for fan styling
          }
          // Only list other viewers, not self (sender)
          if (member.viewerId !== senderId) { // assuming senderId is unique and not used by viewers
            li.textContent = displayName;
            li.classList.add("viewer-item"); // Add a class for all viewer items
            activeViewersList.appendChild(li);
          }
      });
    }


    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
    document.getElementById('cameraBtn').addEventListener('click', () => {
      initCamera();
      updateButtonStates(document.getElementById('cameraBtn'));
    });

    document.getElementById('audioOnlyBtn').addEventListener('click', () => {
      initAudioOnly();
      updateButtonStates(document.getElementById('audioOnlyBtn'));
    });

    document.getElementById('canvasBtn').addEventListener('click', () => {
      initCanvasStream();
      updateButtonStates(document.getElementById('canvasBtn'));
    });

    document.getElementById('screenShareBtn').addEventListener('click', () => {
      initScreenShare();
      updateButtonStates(document.getElementById('screenShareBtn'));
    });

    document.getElementById('dataOnlyBtn').addEventListener('click', () => {
      initDataOnly();
      updateButtonStates(document.getElementById('dataOnlyBtn'));
    });

    sendBtn.addEventListener("click", () => {
      if (selectedRoomId) {
        const message = chatInput.value.trim();
        if (message) {
          // Sender sends message with its own nickname
          ws.send(JSON.stringify({ type: "chat", message: message, roomId: selectedRoomId, from: currentSenderNickname, isFan: false }));
          // Local echo for immediate feedback
          // appendChatMessage(currentSenderNickname, message, false); // Sender is not a fan
          chatInput.value = "";
        }
      }
    });

    chatInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        sendBtn.click();
      }
    });

    // í˜ì´ì§€ ì¢…ë£Œ ì‹œ ì •ë¦¬
    window.addEventListener("beforeunload", () => {
      stopCurrentStream();
      peerConnections.forEach(pc => pc.close());
      ws.close();
    });

    // ì´ˆê¸° ìƒíƒœ ì„¤ì •
    sendBtn.disabled = true; // ë°© ì„¤ì • ì „ê¹Œì§€ ì „ì†¡ ë²„íŠ¼ ë¹„í™œì„±í™”
    updateButtonStates(null); // ëª¨ë“  ìŠ¤íŠ¸ë¦¼ ë²„íŠ¼ ë¹„í™œì„±í™”
  </script>
</body>
</html>